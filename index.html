<!DOCTYPE html>
<html>
<head>
	<title>Raid' Simulator</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.54.0/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

  <script>
  // constants for gameplay to refer to. some of these may stop being constants for e.g. boss variance
  //Strictly a testing comment line.

  const leftPlayBound = 480;
  const rightPlayBound = 1440;
  const topPlayBound = 0;
  const bottomPlayBound = 1080;

  const raidZone = new Phaser.Geom.Rectangle(leftPlayBound, topPlayBound, rightPlayBound, bottomPlayBound);
  const startZone = new Phaser.Geom.Circle(960, 720, 100);

  const damageRange = 100;
  const bossMoveInterval = 5000;
  const bossMechanicInterval = 10000;
  const bossMaxHp = 1000000;
  const pawnDamage = 200;

  //sorry for the big definition here!
  circleAoeRadius = 500;
  const circleAoe = {
        name: 'initialise this from the list somehow',
        chargeTime: 5000,
        damage: 100,
        damageAnimation: null,
        damageRadius: 500,
        checkDamageZone: (pawn, boss) => {
          return Phaser.Math.Distance.Between(pawn.x, pawn.y, boss.x, boss.y) < circleAoeRadius;
        }, 
        getSafeLocation: (pawn, boss) => {
          // pretend circle is rectangle for tractability
          // pick random x in play area
          // pick y that is not inside rectangle
          const minDamageX = boss.x - circleAoeRadius;
          const maxDamageX = boss.x + circleAoeRadius;

          var y;
          const x = Phaser.Math.RND.between(leftPlayBound, rightPlayBound);
          if (x < minDamageX || x > maxDamageX) {
            y = Phaser.Math.RND.between(topPlayBound, bottomPlayBound);
          } else {
            const minDamageY = boss.y - circleAoeRadius;
            const maxDamageY = boss.y + circleAoeRadius;
            const topMargin = minDamageY - topPlayBound;
            const bottomMargin = bottomPlayBound - maxDamageY;
            if (topMargin <= 0) {
              y = Phaser.Math.RND.between(maxDamageY, bottomPlayBound);
            } else if (bottomMargin <= 0) {
              y = Phaser.Math.RND.between(topPlayBound, minDamageY);
            } else {
              const ratio = topMargin/(topMargin + bottomMargin);
              const above = Math.random() < ratio;
              y = above ? Phaser.Math.RND.between(maxDamageY, bottomPlayBound) : Phaser.Math.RND.between(topPlayBound, minDamageY);
            }
          }
          return new Phaser.Math.Vector2(x, y);
        },
      };

  // variables to hold objects that need to persist outside of create/update function calls
  var player;
  var boss;

  var pawns;

  var attackParticle;

  var playerTarget;
  var bossTarget = new Phaser.Math.Vector2();

  var timeText;
  var bossHealthText;
  var mechanicText;

  var nextBossMoveTime;
  var bossHealth;

  var nextMechanicTime;
  var mechanicFireTime;
  var mechanicActive;
  var currentMechanic;

  var mechanics;

  var globalClock;

  // the first scene players see
  const IntroScene = new Phaser.Class({
    Extends: Phaser.Scene,

    initialize: function RaidScene ()
    {
      Phaser.Scene.call(this, { key: 'IntroScene' });
    },

    preload: function () {
      this.load.image('title', 'assets/title.png');
      this.load.image('fullscreen1', 'assets/button-fullscreen-1.png');
      this.load.image('fullscreen2', 'assets/button-fullscreen-2.png');
      this.load.image('start1', 'assets/button-start-1.png');
      this.load.image('start2', 'assets/button-start-2.png');
      this.load.audio('click', 'assets/se-type.wav');
    },

    create: function () {
      this.add.image(960, 540, "title");
      click = this.sound.add("click");

      var fullscreenButton = this.add.image(400, 600, "fullscreen1");
      fullscreenButton.setInteractive();
      fullscreenButton.on('pointerdown', function () {
        console.log ("mal-logging")
        this.remove.image(400, 600, "fullscreen1");
        let fullscreenButton = this.add.image(400, 600, "fullscreen2");
      }, this);  
      fullscreenButton.on('pointerup', function () {
        click.play();
        if (this.scale.isFullscreen) {
          this.scale.stopFullscreen();
        }    
        else {
          this.scale.startFullscreen();
        }
      }, this);  
      
      var goDeeperButton = this.add.image(400, 700, 'start1');
      goDeeperButton.setInteractive();
      goDeeperButton.on('pointerup', function () {
        click.play();
        this.time.delayedCall(500, function () {
          this.scene.start('RaidScene');
        }, {}, this);
      }, this);
    },

    update: function (gameTime) {
      globalClock = gameTime;
    },
  })

  // the gameplay. this should later be able to be called with different boss behaviour
  const RaidScene = new Phaser.Class({

    Extends: Phaser.Scene,

    initialize: function RaidScene ()
    {
      Phaser.Scene.call(this, { key: 'RaidScene' });
    },

    preload: function () {
      this.load.image('player', 'assets/player.png');
      this.load.image('pawn', 'assets/pawn.png');
      this.load.image('boss', 'assets/forgivencuteness.png');
      this.load.image('moveTarget', 'assets/moveTarget.png');

      this.load.image('spark', 'assets/prt.png');
      this.load.image('bullet1', 'assets/bullet1.png');

      this.load.spritesheet('pawnhair1', 'assets/pawnhair1.png', { frameWidth: 48, frameHeight: 36 });
      this.load.spritesheet('pawnhair2', 'assets/pawnhair2.png', { frameWidth: 48, frameHeight: 36 });
      this.load.spritesheet('pawnhair3', 'assets/pawnhair3.png', { frameWidth: 48, frameHeight: 36 });

      this.load.spritesheet('pawnhead1', 'assets/pawnhead1.png', { frameWidth: 48, frameHeight: 28 });

      this.load.spritesheet('pawnbody1', 'assets/pawnbody1.png', { frameWidth: 48, frameHeight: 36 });
      this.load.spritesheet('pawnbody2', 'assets/pawnbody2.png', { frameWidth: 48, frameHeight: 36 });

      this.load.spritesheet('pawnbottom1', 'assets/pawnbottom1.png', { frameWidth: 48, frameHeight: 36 });
      this.load.spritesheet('pawnbottom2', 'assets/pawnbottom2.png', { frameWidth: 48, frameHeight: 36 });
      this.load.spritesheet('pawnbottom3', 'assets/pawnlegs1.png', { frameWidth: 48, frameHeight: 36 });
    },

    create: function (gameTime) {
      // currently not used, was hoping to turn into player attacks later
      particles = this.add.particles('spark');

      player = this.physics.add.image(960, 720, 'player');
      playerTarget = this.physics.add.image(960, 720, 'playerTarget');

      // pawn creation start
      const defineAnims = () => {
        const rate = 1;
        const repeat = 1;
        this.anims.create({
          key: 'hair1down',
          frames: this.anims.generateFrameNumbers('pawnhair1', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });
        this.anims.create({
          key: 'hair2down',
          frames: this.anims.generateFrameNumbers('pawnhair2', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });
        this.anims.create({
          key: 'hair3down',
          frames: this.anims.generateFrameNumbers('pawnhair3', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });

        this.anims.create({
          key: 'head1down',
          frames: this.anims.generateFrameNumbers('pawnhead1', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });

        this.anims.create({
          key: 'body1down',
          frames: this.anims.generateFrameNumbers('pawnbody1', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });
        this.anims.create({
          key: 'body2down',
          frames: this.anims.generateFrameNumbers('pawnbody2', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });

        this.anims.create({
          key: 'bottom1down',
          frames: this.anims.generateFrameNumbers('pawnbottom1', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });
        this.anims.create({
          key: 'bottom2down',
          frames: this.anims.generateFrameNumbers('pawnbottom2', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });
        this.anims.create({
          key: 'bottom3down',
          frames: this.anims.generateFrameNumbers('pawnlegs1', { start: 0, end: 0 }),
          frameRate: rate,
          repeat: repeat
        });
      }

      const composePawn = (container) => {
        const getRandomIndex = (array) => {
          return Math.floor(Math.random() * array.length);
        }
        // get legs
        const legKeys = ['pawnbottom1', 'pawnbottom2', 'pawnbottom3'];
        const legDownAnims = ['bottom1down', 'bottom2down', 'bottom3down'];
        const legIndex = getRandomIndex(legKeys);
        const legKey = legKeys[legIndex];
        var legSprite = this.add.sprite(0, 54, legKey);
        legSprite._downAnimKey = legDownAnims[legIndex];
        container.add(legSprite)

        // get torso
        const torsoKeys = ['pawnbody1', 'pawnbody2'];
        const torsoDownAnims = ['body1down', 'body2down'];
        const torsoIndex = getRandomIndex(torsoKeys);
        const torsoKey = torsoKeys[torsoIndex];
        torsoSprite = this.add.sprite(0, 18, torsoKey);
        torsoSprite._downAnimKey = torsoDownAnims[torsoIndex];
        container.add(torsoSprite)

        // get head
        const headKey = 'pawnhead1';
        headSprite = this.add.sprite(0, -12, headKey);
        headSprite._downAnimKey = 'head1down';
        container.add(headSprite)

        // get hair
        const hairKeys = ['pawnhair1', 'pawnhair2', 'pawnhair3'];
        const hairDownAnims = ['hair1down', 'hair2down', 'hair3down'];
        const hairIndex = getRandomIndex(hairKeys);
        const hairKey = hairKeys[hairIndex];
        var hairSprite = this.add.sprite(0, 0, hairKey);
        hairSprite._downAnimKey = hairDownAnims[hairIndex];
        container.add(hairSprite)
      }

      const addPawnEmitter = (container) => {
        var emitter = particles.createEmitter({
          x: container.x,
          y: container.y,
          speed: 50,
          quantity: 0.01,
          scale: { start: 0.1, end: 0.2 },
        });

        emitter.setSpeed(50);
        emitter.setBlendMode(Phaser.BlendModes.ADD);
        // emitter.pause();

        container.add(emitter);
      }

      pawns = this.physics.add.group();

      var i
      for (i=0; i<8; i++) {
        const pawn = this.add.container();
        this.physics.world.enable(pawn);
        composePawn(pawn);
        // addPawnEmitter(pawn);
        pawns.add(pawn);
      }
      this.anims.create({
        key: 'down',
        frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 0 }),
        frameRate: 0,
        repeat: 0
      });

      Phaser.Actions.RandomCircle(pawns.getChildren(), startZone);
      pawns.getChildren().forEach(pawn => {
        pawn.targetLocation = new Phaser.Geom.Point(pawn.x, pawn.y);
        pawn.pawnAttackInterval = Phaser.Math.RND.between(250, 400)
        pawn.nextPawnAttackTime = globalClock + pawn.pawnAttackInterval
        pawn.pawnMoveInterval = Phaser.Math.RND.between(100, 400)
        pawn.nextPawnMoveTime = globalClock + pawn.pawnMoveInterval;
        pawn.respondingToMechanic = false;
      }, this);
      // pawn creation end

      boss = this.physics.add.image(960, 200, 'boss')

      this.input.on('pointerdown', function (pointer)
        {
          playerTarget.setPosition(pointer.x, pointer.y);
          this.physics.moveToObject(player, playerTarget, 240);
        }, this
      );

      timeText = this.add.text(10, 10, 'Time: ', { fill: '#00ff00' });
      bossHealthText = this.add.text(10, 30, 'Boss Hp: ', { fill: '#00ff00' });
      mechanicText = this.add.text(10, 50, 'No Mechanic', { fill: '#00ff00' });

      nextBossMoveTime = globalClock + bossMoveInterval;
      bossHealth = bossMaxHp;

      mechanicActive = false;
      nextMechanicTime = globalClock + bossMechanicInterval;
    },

    update: function(gameTime, delta) {
      globalClock = gameTime;
      timeText.setText('Time: ' + globalClock);
      bossHealthText.setText(bossHealth + '/' + bossMaxHp);
      if (bossHealth <= 0) {
        this.scene.start('IntroScene');
      }

      if (mechanicActive && globalClock > mechanicFireTime) {
        // play anim
        // check for damage
        // turn off mechanic response
        pawns.getChildren().forEach(pawn => {pawn.respondingToMechanic = false}, this);
        nextMechanicTime = globalClock + bossMechanicInterval;
        mechanicActive = false;
        mechanicText.setText('No Mechanic')
      }

      if (!mechanicActive && globalClock > nextMechanicTime) {
        mechanicActive = true;
        currentMechanic = circleAoe; // this will later need to be from somewhere
        mechanicFireTime = globalClock + currentMechanic.chargeTime;
        nextBossMoveTime = mechanicFireTime + bossMoveInterval;
        mechanicText.setText('Mechanic Active!')
      }

      const checkStop = (object, target) => {
        var distance = Phaser.Math.Distance.Between(object.x, object.y, target.x, target.y);
        if (object.body.speed > 0 && distance < 8)
        {
          object.body.reset(target.x, target.y);
        }
      }

      if (gameTime > nextBossMoveTime) {
        nextBossMoveTime = globalClock + bossMoveInterval;
        bossTarget.x = Phaser.Math.RND.between(480, 1440);
        bossTarget.y = Phaser.Math.RND.between(0, 1080);
        this.physics.moveToObject(boss, bossTarget, 240);
      }

      const bossDamageCircle = new Phaser.Geom.Circle(boss.x, boss.y, damageRange);

      const pawnAttack = (pawn) => {
        if (gameTime > pawn.nextPawnAttackTime) {
          if (bossDamageCircle.contains(pawn.x, pawn.y)) {
            pawn.nextPawnAttackTime = gameTime + pawn.pawnAttackInterval
            // sfx
            bossHealth = bossHealth - pawnDamage;
          }
        }
      }

      const movePawn = (pawn) => {
        if (true) { // direction checker later
          // const components = pawn.getAll('_downAnimKey');
          // components.forEach(component => component.anims.play(component._downAnimKey))
        }
        if (gameTime > pawn.nextPawnMoveTime) {
          pawn.nextPawnMoveTime = globalClock + pawn.pawnMoveInterval;
          if (mechanicActive) {
            if (true) { // knows mechanic check
              if (!pawn.respondingToMechanic) {
                pawn.respondingToMechanic = true;
                pawn.targetLocation = currentMechanic.getSafeLocation(pawn, boss);
                this.physics.moveToObject(pawn, pawn.targetLocation, 240);
              }
            }
            // flock, or freeze in headlights since that isn't done yet!
          } else {
            if (!bossDamageCircle.contains(pawn.x, pawn.y)) {
              pawn.targetLocation = Phaser.Geom.Circle.Random(bossDamageCircle);
              this.physics.moveToObject(pawn, pawn.targetLocation, 240);
            }
          }
        }
        checkStop(pawn, pawn.targetLocation);
      }

      pawns.getChildren().forEach(pawn => {
        pawnAttack(pawn);
        movePawn(pawn);
      }, this);

      checkStop(boss, bossTarget);
      checkStop(player, playerTarget);
    }
  });

  var config = {
      type: Phaser.AUTO,
      width: 1920,
      height: 1080,
      physics: {
          default: 'arcade',
          arcade: {
              gravity: { y: 0 },
              debug: true
          }
      },
      scene: [IntroScene, RaidScene]
  };

  var game = new Phaser.Game(config);

  </script>

</body>
</html>
